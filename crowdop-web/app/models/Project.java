package models;

import java.util.*;
import javax.persistence.*;
import play.db.ebean.*;

import sg.edu.nus.comp.crowdop.core.model.*;
import sg.edu.nus.comp.crowdop.core.plangen.*;
import sg.edu.nus.comp.datastore.DataStore;
import sg.edu.nus.comp.datastore.plugin.*;

@Entity
public class Project extends Model {

    public static final int STATE_INIT = 0;
    public static final int STATE_ONGO = 1;
    public static final int STATE_COMP = 2;

    @Id
    public Long id;

    public String name; // the name of project
    public String queryStat; // the query describing the intend
    public Double budget; // the budget for crowdsourcing
    public int state; // state of the project

    @ManyToOne
    public User owner; // the owner of the project

    @ManyToOne
    public DataSource destDataSource; 
    // the destination data source
    
    public double priceCSelectBase;
    public double priceCSelectInc;
    public double priceCJoinBase;
    public double priceCJoinInc;
    public double priceCFillBase;
    public double priceCFillInc;


    public Project(String name, String queryStat, User owner) {
        this.name = name;
        this.queryStat = queryStat;
        this.budget = null;
        this.owner = owner;
        state = STATE_INIT;
    }

    /*
     * Create a project with default settings
     */
    public static Project create(String name, String queryStat, String owner) {
        Project project = new Project(name, queryStat, User.find.ref(owner));
        project.save();
        return project;
    }

    /*
     * The finding functions
     */
    public static Model.Finder<Long,Project> find = new Model.Finder(Long.class, Project.class);

    public static List<Project> findInvolving(String user) {
        return find.where()
            .eq("owner.email", user)
            .findList();
    }

    public static boolean isMember(Long project, String user) {
        return find.where()
            .eq("owner.email", user)
            .eq("id", project)
            .findRowCount() > 0;
    }

    /*
     * The update functions
     */

    public static String rename(Long projectId, String newName) {
        Project project = find.ref(projectId);
        project.name = newName;
        project.update();
        return newName;
    }

    public static String updateQueryStat(Long projectId, String queryStat, 
        Long destDataId) {
        DataSource destDataSource = DataSource.find.ref(destDataId);
        Project project = find.ref(projectId);
        project.queryStat = queryStat;
        project.destDataSource = destDataSource;
        project.update();
        return queryStat;
    }

    public static void updatePriceModel(Long projectId, Double cselectBase, Double cselectInc,
                Double cjoinBase, Double cjoinInc, Double cfillBase, Double cfillInc) {
        Project project = find.ref(projectId);
        project.priceCSelectBase = cselectBase;
        project.priceCSelectInc = cselectInc;
        project.priceCJoinBase = cjoinBase;
        project.priceCJoinInc = cjoinInc;
        project.priceCFillBase = cfillBase;
        project.priceCFillInc = cfillInc;
        project.update();
    }


    /*
     * Create Jobs based on the plan generated by our CrowdOp backend
     */
    public static void createJobs (Long projectId) throws Exception {
        Project project = find.ref(projectId);
        CrowdPricing cprice = new LinearCrowdPricing (
            project.priceCSelectBase, project.priceCSelectInc, 
            project.priceCJoinBase, project.priceCJoinInc, 
            project.priceCFillBase, project.priceCFillInc);
        // Crowdsourcing price model
        CrowdPlan crowdPlan = PlanGen.generatePlan (
            DataSource.dataStore, DataSource.summaryStore, 
            project.queryStat, project.budget, cprice);

        List<List<CrowdUnit>> cgroups = crowdPlan.batchlist;
        Map<Integer, Job> jobFind = new HashMap<Integer, Job> ();
        for (int i = 0; i < cgroups.size(); i ++) {
            String folder = "Crowdsourcing Batch #" + (i + 1);
            for (CrowdUnit cunit : cgroups.get(i)) { // for each unit
                String name = "Job #" + cunit.op.getID();
                // - Initialize the state of the job
                String state = Job.STATE_WAITING;
                if (cunit.inputIds.size() == 0) 
                    state = Job.STATE_PENDING; // the first job

                // - Initialize the output dat source
                DataSource outData = null; // out data source
                if (i < cgroups.size() - 1) { // intermediate steps
                    outData = DataSource.create ("tmp", DataSource.TYPE_TEMP, 
                        project.owner.email); // create a tmp store
                } else {
                    outData = project.destDataSource; // use the dest store
                    if (outData.getDataTable() == null) {
                        outData.createDataTable();
                    }
                }
                
                // - Create a new job
                Job job = Job.create(folder, name,  
                    cunit.op.toJSON().toString(), 
                    cunit.taskPrice, 
                    projectId, 
                    outData.id,
                    state);

                jobFind.put (cunit.op.getID(), job);

                // - Link the job with its successor
                for (int inputId : cunit.inputIds) {
                    Job depJob = jobFind.get(inputId);
                    Job.setSuccessor (depJob.id, job.id);
                }
            }
        }
        project.state = STATE_ONGO; // change the state of the project
        project.update();
    }
}









